## 🧨 What Happened (문제 상황)

1. 팀 프로젝트에서 **SSE 알림을 특정 시각에 표시**하려 했으나 `chunk` 에러로 실패함.
2. **개발 서버 종료** 이후 재현이 어려웠고, **라우터 가드/로그인 상태/데이터 초기화 로직이 뒤섞여** 임시 수정이 곤란한 구조였음.

---

## 🔎 Why (원인 분석)

- **네트워크/인프라 측면**
  - `Content-Type: text/event-stream` 누락 또는 중간 프록시의 **버퍼링/타임아웃** 문제.
  - **Gzip 압축** 또는 **Chunked 전송** 충돌.
  - **서버의 heartbeat(주기적 keep-alive)** 미흡 → 프록시에서 idle timeout 발생.

- **앱 설계 측면**
  - **Auth Guard**와 **데이터 초기화**가 결합되어, 인증/라우팅/데이터 부트스트랩 경계가 불분명.
  - 로그인 흐름(`/auth/me`)과 페이지 초기화가 의존 관계로 얽혀 있어 테스트/수정이 어려웠음.

---

## 🛠 Fix Plan (개선 설계)

- **SSE 서버 개선**
  - 응답 헤더:

    ```http
    Content-Type: text/event-stream; charset=utf-8
    Cache-Control: no-cache, no-transform
    Connection: keep-alive
    ```

  - **25초 heartbeat(`event: ping`) 주기 전송**
  - **CORS 명시** 및 gzip 비활성화 (`compression: false`)

- **클라이언트 구조 리팩토링**
  - `AuthBoundary` 컴포넌트에서 로그인/토큰/프로필 부트스트랩 전담.
  - `AppRoutes`는 라우팅 판단만 담당 (데이터 초기화 로직 제거).
  - SSE 수신 시 `queryClient.invalidateQueries(['alarms'])`로 **데이터 갱신 단일화**.

---

## 🎬 Demo (간단 시연 GIF 계획)

- **시나리오**: 알람 수정 → SSE 이벤트 수신 → **알람 목록 자동 갱신 (캐시 무효화)**
- **재현 절차 (데모 브랜치 기준)**

  ```bash
  pnpm run sse          # 로컬 SSE 서버 실행 (demo/sse/sse-server.ts)
  pnpm run dev:demo     # mock 환경으로 프론트 실행

  # 선택적으로 SSE 이벤트 수동 트리거
  curl -X POST "http://localhost:4000/emit?type=ALARM_UPDATED"
  ```

- **성공 기준**
  - 브라우저 네트워크 탭에서 `text/event-stream` 지속 연결 확인
  - 25±5초 간격으로 heartbeat 수신
  - 이벤트 수신 시 알람 목록이 자동으로 갱신됨 (React Query 캐시 무효화 확인)

---

## 📈 What I Learned (회고)

- 문제의 본질은 SSE 연결보다, 개발 환경에서 발생한 에러를 구조적으로 재현·검증할 수 없는 설계에 있었다.
- 인증·라우팅·데이터 초기화가 뒤섞인 구조에서는 작은 수정이나 임시 테스트조차 어렵다.
- 이후에는 기능 단위로 로컬에서 독립적으로 재현 가능한 구조(데모/Mock 환경) 를 먼저 갖추는 것이 중요함을 느꼈다.
- 마지막으로, 베스트 케이스 시연 GIF를 남기는 습관을 통해 문제 해결 방향을 명확히 기록해야 함을 배움.
